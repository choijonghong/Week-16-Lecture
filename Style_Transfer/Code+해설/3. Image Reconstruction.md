# **🖼️ 이미지 재구성(Image Reconstruction) 코드 해설**

이 실습은 무작위 노이즈(Noise) 상태의 이미지를 수학적 최적화 과정을 거쳐 목표 이미지(Target)와 동일하게 변화시키는 과정을 다룹니다.

### **1\. 목표 설정: 무엇을 만들 것인가?**

우리가 최종적으로 도달해야 할 \*\*'정답지'\*\*를 준비하는 단계입니다.

img\_path \= './code\_practices/images/cat.jpg'  
target\_image \= image\_loader(img\_path, (512, 512))

* **해설:** 512x512 크기의 고양이 사진을 불러와 기준점으로 삼습니다.

### **2\. 시작점: 무작위 노이즈 생성**

아무것도 없는 엉망진창인 상태에서 시작합니다.

noise \= torch.empty\_like(target\_image).uniform(0, 1).to(device)

* **해설:** 정답지와 크기는 같지만, 내용은 '치익' 소리가 나는 TV 화면 같은 무작위 노이즈로 채워진 캔버스를 만듭니다. 처음에는 고양이의 형체를 전혀 알 수 없습니다.

### **3\. 도구 준비: 오차 계산 및 설정**

얼마나 틀렸는지 계산하고, 얼마나 반복할지 결정합니다.

* **loss \= nn.MSELoss()**: 노이즈와 정답 사진의 픽셀 차이(오차)를 계산하는 도구입니다.  
* **iters \= 100**: 수정을 총 100번 반복합니다.  
* **lr \= 1e-4**: 한 번 수정할 때 적용할 강도(학습률)입니다.

### **4\. 핵심 과정: 정답을 향해 다듬기 (Loop)**

반복문을 통해 이미지를 조금씩 정답에 가깝게 수정합니다.

for i in range(iters):  
    noise.requires\_grad \= True       \# (1) 픽셀의 수정 방향 기록 준비  
    output \= loss(noise, target\_image) \# (2) 현재 이미지와 정답의 오차 계산  
    output.backward()                \# (3) 오차를 줄이기 위한 수정 방향(미분) 계산

    gradient \= lr \* noise.grad       \# (4) 계산된 방향에 강도를 곱해 수정안 생성  
    noise \= torch.clamp(noise \- gradient, min=0, max=1).detach\_() \# (5) 실제 수정 및 범위 제한

### **💡 쉽게 풀이한 5단계 과정**

1. **추적 시작**: 픽셀 값이 어떻게 변해야 하는지 계산할 준비를 합니다.  
2. **오차 확인**: 현재 내 이미지와 진짜 고양이 사진이 얼마나 다른지 점수를 냅니다.  
3. **수정 방향 찾기**: 각 픽셀을 밝게 할지 어둡게 할지 결정하는 '기울기'를 구합니다.  
4. **수정 강도 조절**: 찾은 방향에 학습률을 곱해 실제 수정할 양을 정합니다.  
5. **적용 및 제한**: 이미지에서 오차를 뺍니다. 이때 색상 값은 반드시 0(검정)에서 1(흰색) 사이여야 하므로 범위를 제한(clamp)합니다.

### **📈 결과 및 원리**

* **Step 1:** 무작위 점들만 보이는 상태  
* **Step 50:** 고양이의 실루엣이 흐릿하게 나타남  
* **Step 100:** 원래 고양이 이미지와 거의 똑같이 변함

핵심 원리:  
이 과정은 딥러닝 모델이 학습하는 원리와 동일합니다. 일반적인 딥러닝은 모델의 \*\*가중치(Weight)\*\*를 업데이트하지만, 이 실습에서는 \*\*이미지 픽셀(Pixel)\*\*을 직접 업데이트하여 정답을 찾아간다는 점이 특징입니다.